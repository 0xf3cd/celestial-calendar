name: Build and Test on Multiple Platforms

on:
  workflow_dispatch: {}  # Allows manual triggering of the workflow
  # pull_request:
  #   branches: [ main ]  # Also triggers on pull requests to the main branch

jobs:
  linux-docker:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: 
          - "linux/amd64"
          - "linux/i386"
          - "linux/arm64"
          - "linux/arm/v5"
          - "linux/arm/v7"
          - "linux/mips64le"
          - "linux/ppc64le"
          - "linux/s390x"
          - "linux/riscv64"

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine BASE_IMAGE
        id: determine-base-image
        run: |
          echo "PACKAGE_MANAGER=apt-get" >> $GITHUB_OUTPUT
          case "${{ matrix.platform }}" in
            "linux/amd64") 
              echo "BASE_IMAGE=debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/i386")
              echo "BASE_IMAGE=i386/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/arm64")
              echo "BASE_IMAGE=arm64v8/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/arm/v5")
              echo "BASE_IMAGE=arm32v5/debian:latest" >> $GITHUB_OUTPUT
              echo "PACKAGE_MANAGER=aptitude" >> $GITHUB_OUTPUT
              ;;
            "linux/arm/v7")
              echo "BASE_IMAGE=arm32v7/debian:latest" >> $GITHUB_OUTPUT
              echo "PACKAGE_MANAGER=aptitude" >> $GITHUB_OUTPUT
              ;;
            "linux/mips64le")
              echo "BASE_IMAGE=mips64le/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/ppc64le")
              echo "BASE_IMAGE=ppc64le/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/s390x")
              echo "BASE_IMAGE=s390x/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/riscv64")
              echo "BASE_IMAGE=riscv64/debian:sid" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Set up Environment Variables
        run: |
          # Print the BASE_IMAGE and PACKAGE_MANAGER
          echo "BASE_IMAGE set to ${{ steps.determine-base-image.outputs.BASE_IMAGE }}"
          echo "PACKAGE_MANAGER set to ${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }}"
          
          echo "BASE_IMAGE=${{ steps.determine-base-image.outputs.BASE_IMAGE }}" >> $GITHUB_ENV
          echo "PACKAGE_MANAGER=${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }}" >> $GITHUB_ENV

          platform="${{ matrix.platform }}"
          os=$(echo "${platform}" | cut -d '/' -f 1)
          arch=$(echo "${platform}" | cut -d '/' -f 2- | tr '/' '_')

          image_tag="celestial-calendar-${os}-${arch}"
          proj_dir=$(pwd)
          output_dir="${proj_dir}/output_${os}_${arch}"

          # Set environment variables
          echo "OS=${os}" >> $GITHUB_ENV
          echo "ARCH=${arch}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${image_tag}" >> $GITHUB_ENV
          echo "PROJ_DIR=${proj_dir}" >> $GITHUB_ENV
          echo "OUTPUT_DIR=${output_dir}" >> $GITHUB_ENV

      - name: Clean up Output Directory
        run: |
          # Remove the output directory if it exists and recreate it
          if [ -d "$OUTPUT_DIR" ]; then
            rm -rf "$OUTPUT_DIR"
          fi
          mkdir -p "$OUTPUT_DIR"

      - name: Build and Run Docker Image
        run: |
          # Set up QEMU for cross-compilation
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes

          # Create and use a new Buildx builder instance
          docker buildx create --use

          # Build the Docker image for the specified platform
          docker buildx build \
            --platform $OS/$ARCH -t $IMAGE_TAG \
            --build-arg BASE_IMAGE=${{ steps.determine-base-image.outputs.BASE_IMAGE }} \
            --build-arg PACKAGE_MANAGER=${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }} \
            --load .

          # Run the Docker image and copy build artifacts to the output directory
          docker run --rm -v $OUTPUT_DIR:/output $IMAGE_TAG /bin/bash -c 'tree /app/build && cp -r /app/build/shared_lib /output/'


      - name: Rename Shared Library
        id: shared_lib
        run: |
          cd "$OUTPUT_DIR/shared_lib"
          libs=(*.[sod]*)

          # Check if exactly one shared library is found
          if [ ${#libs[@]} -eq 1 ]; then
            lib="${libs[0]}"
            extension="${lib##*.}"
            new_name="lib_celecalendar_${OS}_${ARCH}.${extension}"

            # Rename the shared library
            sudo mv "$lib" "$new_name" # Fail without sudo permission
            echo "Renamed $lib to $new_name"

            # Set the lib environment variables
            echo "lib_name=${new_name}" >> $GITHUB_ENV
            echo "lib_name=${new_name}" >> $GITHUB_OUTPUT

            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_ENV
            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_OUTPUT

            # Print to stdout
            echo "lib_name=${lib_name}"
            echo "lib_path=${lib_path}"
          
          else
            # Handle cases where no or multiple shared libraries are found
            [ ${#libs[@]} -gt 1 ] && echo "More than one shared library found. Stopping execution." || echo "No shared library found."
            exit 1
          
          fi 

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.shared_lib.outputs.lib_name }}
          path: ${{ steps.shared_lib.outputs.lib_path }}
          retention-days: 30
          if-no-files-found: error


  macos:
    runs-on: macos-latest
    strategy:  
      matrix:  
        python-version: ["3.12"]  

    steps:
    - uses: actions/checkout@v4

    - uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Set up Python ${{ matrix.python-version }}  
      uses: actions/setup-python@v5 
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install Python Dependencies
      run: |  
        python3 -m pip install --upgrade pip  
        if [ -f Requirements.txt ]; then python3 -m pip install -r Requirements.txt; fi

    - name: Build and Test
      env:
        CXX: clang++
        CC:  clang
      run: |
        chmod +x automation.py
        ./automation.py --setup --clean --cmake --build --test -v 1

    - name: Ensure Shared Lib Exists
      id: shared_lib
      run: |
        # Should be in ./build/shared_lib/*.dylib
        ls ./build/shared_lib

        if [ ! -f ./build/shared_lib/*.dylib ]; then
          echo "No shared lib found"
          exit 1
        fi

        # Rename the lib to lib_celecalendar_macos_arm64.dylib
        mv ./build/shared_lib/*.dylib ./build/shared_lib/lib_celecalendar_macos_arm64.dylib

        # If exists, save the path to GITHUB_OUTPUT
        echo "lib_name=lib_celecalendar_macos_arm64.dylib" >> $GITHUB_OUTPUT
        echo "lib_path=$(pwd)/build/shared_lib/lib_celecalendar_macos_arm64.dylib" >> $GITHUB_OUTPUT

        # Print to stdout
        echo "lib_name=${lib_name}"
        echo "lib_path=${lib_path}"

    - name: GitHub Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.shared_lib.outputs.lib_name }}
        path: ${{ steps.shared_lib.outputs.lib_path }}
        retention-days: 30
        if-no-files-found: error


  windows:
    runs-on: windows-latest
    strategy:  
      matrix:  
        python-version: ["3.12"]  
  
    steps:  
      - uses: actions/checkout@v4

      - name: Set up Visual Studio
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: latest

      - name: Set up Python ${{ matrix.python-version }}  
        uses: actions/setup-python@v5 
        with:
          python-version: ${{ matrix.python-version }}
  
      - name: Install Dependencies
        run: |  
          python3 -m pip install --upgrade pip  
          if (Test-Path "Requirements.txt") { python3 -m pip install -r "Requirements.txt" }

          choco install -y make llvm

      - name: Build and Test
        env:
          CXX: clang++
          CC:  clang
        run: |
          chcp.com 65001
          $env:PYTHONIOENCODING = "utf-8"
          python3 ./automation.py --setup --clean --cmake --build --test -v 1

      - name: Ensure Shared Lib Exists
        id: shared_lib
        run: |
          # Should be in ./build/shared_lib. Looking for .dll, .lib, and .pdb

          $dllPath = Get-ChildItem -Path "./build/shared_lib" -Filter *.dll | Select-Object -First 1
          $libPath = Get-ChildItem -Path "./build/shared_lib" -Filter *.lib | Select-Object -First 1
          $pdbPath = Get-ChildItem -Path "./build/shared_lib" -Filter *.pdb | Select-Object -First 1

          Write-Output "DLL Path: $dllPath"
          Write-Output "LIB Path: $libPath"
          Write-Output "PDB Path: $pdbPath"

          if ((Test-Path $dllPath) -and (Test-Path $libPath) -and (Test-Path $pdbPath)) {
            Rename-Item -Path $dllPath -NewName "lib_celecalendar_windows_x86_64.dll"
            Rename-Item -Path $libPath -NewName "lib_celecalendar_windows_x86_64.lib"
            Rename-Item -Path $pdbPath -NewName "lib_celecalendar_windows_x86_64.pdb"

            Write-Output "dll_name=lib_celecalendar_windows_x86_64.dll" >> $env:GITHUB_OUTPUT
            Write-Output "lib_name=lib_celecalendar_windows_x86_64.lib" >> $env:GITHUB_OUTPUT
            Write-Output "pdb_name=lib_celecalendar_windows_x86_64.pdb" >> $env:GITHUB_OUTPUT

            Write-Output "dll_path=$(Resolve-Path ./build/shared_lib/lib_celecalendar_windows_x86_64.dll)" >> $env:GITHUB_OUTPUT
            Write-Output "lib_path=$(Resolve-Path ./build/shared_lib/lib_celecalendar_windows_x86_64.lib)" >> $env:GITHUB_OUTPUT
            Write-Output "pdb_path=$(Resolve-Path ./build/shared_lib/lib_celecalendar_windows_x86_64.pdb)" >> $env:GITHUB_OUTPUT
          } else {
            Write-Error "Shared library (.dll), import library (.lib), or debug file (.pdb) not found."
            exit 1
          }

      - name: GitHub Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.shared_lib.outputs.dll_path }}
          path: |
            ${{ steps.shared_lib.outputs.dll_path }}
            ${{ steps.shared_lib.outputs.lib_path }}
            ${{ steps.shared_lib.outputs.pdb_path }}
          retention-days: 30
          if-no-files-found: error
