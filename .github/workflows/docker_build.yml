name: Build and Test with Docker Images (Debian latest / g++14)

on:
  workflow_dispatch: {}  # Allows manual triggering of the workflow
  # pull_request:
  #   branches: [ main ]  # Also triggers on pull requests to the main branch

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: 
          - "linux/amd64"
          - "linux/i386"
          - "linux/arm64"
          - "linux/arm/v5"
          - "linux/arm/v7"
          - "linux/mips64le"
          - "linux/ppc64le"
          - "linux/s390x"
          - "linux/riscv64"

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine BASE_IMAGE
        id: determine-base-image
        run: |
          echo "PACKAGE_MANAGER=apt-get" >> $GITHUB_OUTPUT
          case "${{ matrix.platform }}" in
            "linux/amd64") 
              echo "BASE_IMAGE=debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/i386")
              echo "BASE_IMAGE=i386/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/arm64")
              echo "BASE_IMAGE=arm64v8/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/arm/v5")
              echo "BASE_IMAGE=arm32v5/debian:latest" >> $GITHUB_OUTPUT
              echo "PACKAGE_MANAGER=aptitude" >> $GITHUB_OUTPUT
              ;;
            "linux/arm/v7")
              echo "BASE_IMAGE=arm32v7/debian:latest" >> $GITHUB_OUTPUT
              echo "PACKAGE_MANAGER=aptitude" >> $GITHUB_OUTPUT
              ;;
            "linux/mips64le")
              echo "BASE_IMAGE=mips64le/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/ppc64le")
              echo "BASE_IMAGE=ppc64le/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/s390x")
              echo "BASE_IMAGE=s390x/debian:latest" >> $GITHUB_OUTPUT
              ;;
            "linux/riscv64")
              echo "BASE_IMAGE=riscv64/debian:sid" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Set up environment variables
        run: |
          # Print the BASE_IMAGE and PACKAGE_MANAGER
          echo "BASE_IMAGE set to ${{ steps.determine-base-image.outputs.BASE_IMAGE }}"
          echo "PACKAGE_MANAGER set to ${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }}"
          
          echo "BASE_IMAGE=${{ steps.determine-base-image.outputs.BASE_IMAGE }}" >> $GITHUB_ENV
          echo "PACKAGE_MANAGER=${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }}" >> $GITHUB_ENV

          platform="${{ matrix.platform }}"
          os=$(echo "${platform}" | cut -d '/' -f 1)
          arch=$(echo "${platform}" | cut -d '/' -f 2- | tr '/' '_')

          image_tag="celestial-calendar-${os}-${arch}"
          proj_dir=$(pwd)
          output_dir="${proj_dir}/output_${os}_${arch}"

          # Set environment variables
          echo "OS=${os}" >> $GITHUB_ENV
          echo "ARCH=${arch}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${image_tag}" >> $GITHUB_ENV
          echo "PROJ_DIR=${proj_dir}" >> $GITHUB_ENV
          echo "OUTPUT_DIR=${output_dir}" >> $GITHUB_ENV

      - name: Clean up output directory
        run: |
          # Remove the output directory if it exists and recreate it
          if [ -d "$OUTPUT_DIR" ]; then
            rm -rf "$OUTPUT_DIR"
          fi
          mkdir -p "$OUTPUT_DIR"

      - name: Build and run Docker image
        run: |
          # Set up QEMU for cross-compilation
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes

          # Create and use a new Buildx builder instance
          docker buildx create --use

          # Build the Docker image for the specified platform
          docker buildx build \
            --platform $OS/$ARCH -t $IMAGE_TAG \
            --build-arg BASE_IMAGE=${{ steps.determine-base-image.outputs.BASE_IMAGE }} \
            --build-arg PACKAGE_MANAGER=${{ steps.determine-base-image.outputs.PACKAGE_MANAGER }} \
            --load .

          # Run the Docker image and copy build artifacts to the output directory
          docker run --rm -v $OUTPUT_DIR:/output $IMAGE_TAG /bin/bash -c 'tree /app/build && cp -r /app/build/shared_lib /output/'


      - name: Rename shared library
        id: rename_lib
        run: |
          cd "$OUTPUT_DIR/shared_lib"
          libs=(*.[sod]*)

          # Check if exactly one shared library is found
          if [ ${#libs[@]} -eq 1 ]; then
            lib="${libs[0]}"
            extension="${lib##*.}"
            new_name="lib_celecalendar_${OS}_${ARCH}.${extension}"

            # Rename the shared library
            sudo mv "$lib" "$new_name" # Fail without sudo permission
            echo "Renamed $lib to $new_name"

            # Set the lib environment variables
            echo "lib_name=${new_name}" >> $GITHUB_ENV
            echo "lib_name=${new_name}" >> $GITHUB_OUTPUT

            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_ENV
            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_OUTPUT

            # Print to stdout
            echo "lib_name=${lib_name}"
            echo "lib_path=${lib_path}"
          
          else
            # Handle cases where no or multiple shared libraries are found
            [ ${#libs[@]} -gt 1 ] && echo "More than one shared library found. Stopping execution." || echo "No shared library found."
            exit 1
          
          fi 

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          # Upload the renamed shared library as an artifact
          name: ${{ steps.rename_lib.outputs.lib_name }}
          path: ${{ steps.rename_lib.outputs.lib_path }}
          retention-days: 30
          if-no-files-found: error
