name: Shared Library Builders

on:
  workflow_dispatch: {}  # Allows manual triggering of the workflow
  pull_request:
    branches: [ main ]  # Also triggers on pull requests to the main branch

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: 
          - "linux/amd64"
          - "linux/arm64"

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up environment variables
        run: |
          platform="${{ matrix.platform }}"
          os=$(echo "${platform}" | cut -d '/' -f 1)
          arch=$(echo "${platform}" | cut -d '/' -f 2- | tr '/' '_')

          image_tag="celestial-calendar-${os}-${arch}"
          proj_dir=$(pwd)
          output_dir="${proj_dir}/output_${os}_${arch}"

          # Set environment variables
          echo "OS=${os}" >> $GITHUB_ENV
          echo "ARCH=${arch}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${image_tag}" >> $GITHUB_ENV
          echo "PROJ_DIR=${proj_dir}" >> $GITHUB_ENV
          echo "OUTPUT_DIR=${output_dir}" >> $GITHUB_ENV

      - name: Clean up output directory
        run: |
          # Remove the output directory if it exists and recreate it
          if [ -d "$OUTPUT_DIR" ]; then
            rm -rf "$OUTPUT_DIR"
          fi
          mkdir -p "$OUTPUT_DIR"

      - name: Build and run Docker image
        run: |
          # Set up QEMU for cross-compilation
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
          # Create and use a new Buildx builder instance
          docker buildx create --use
          # Build the Docker image for the specified platform
          docker buildx build --platform $OS/$ARCH -t $IMAGE_TAG --build-arg BASE_IMAGE=ubuntu:24.04 --load .
          # Run the Docker image and copy build artifacts to the output directory
          docker run --rm -v $OUTPUT_DIR:/output $IMAGE_TAG
          docker run --rm -v $OUTPUT_DIR:/output $IMAGE_TAG /bin/bash -c 'tree /app/build'
          docker run --rm -v $OUTPUT_DIR:/output $IMAGE_TAG /bin/bash -c 'cp -r /app/build/shared_lib /output/'

      - name: Rename shared library
        id: rename_lib
        run: |
          cd "$OUTPUT_DIR/shared_lib"
          libs=(*.[sod]*)

          # Check if exactly one shared library is found
          if [ ${#libs[@]} -eq 1 ]; then
            lib="${libs[0]}"
            extension="${lib##*.}"
            new_name="lib_celecalendar_${OS}_${ARCH}.${extension}"

            # Rename the shared library
            sudo mv "$lib" "$new_name" # Fail without sudo permission
            echo "Renamed $lib to $new_name"

            # Set the lib environment variables
            echo "lib_name=${new_name}" >> $GITHUB_ENV
            echo "lib_name=${new_name}" >> $GITHUB_OUTPUT

            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_ENV
            echo "lib_path=${OUTPUT_DIR}/shared_lib/${new_name}" >> $GITHUB_OUTPUT
          
          else
            # Handle cases where no or multiple shared libraries are found
            [ ${#libs[@]} -gt 1 ] && echo "More than one shared library found. Stopping execution." || echo "No shared library found."
            exit 1
          
          fi

      - name: Debug environment variables
        run: |
          # Print the archive_name variable for debugging
          echo "lib_name=${{ steps.rename_lib.outputs.lib_name }}"
          echo "lib_path=${{ steps.rename_lib.outputs.lib_path }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          # Upload the renamed shared library as an artifact
          name: ${{ steps.rename_lib.outputs.lib_name }}
          path: ${{ steps.rename_lib.outputs.lib_path }}
          retention-days: 30
          if-no-files-found: error
